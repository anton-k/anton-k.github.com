<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="./style.css" type="text/css" />
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#функции-высшего-порядка">Функции высшего порядка</a><ul>
<li><a href="#обобщённые-функции">Обобщённые функции</a><ul>
<li><a href="#функция-тождества">Функция тождества</a></li>
<li><a href="#константная-функция">Константная функция</a></li>
<li><a href="#функция-композиции">Функция композиции</a></li>
<li><a href="#аналогия-с-числами">Аналогия с числами</a></li>
<li><a href="#функция-перестановки">Функция перестановки</a></li>
<li><a href="#функция-on">Функция on</a></li>
<li><a href="#функция-применения">Функция применения</a></li>
</ul></li>
<li><a href="#приоритет-инфиксных-операций">Приоритет инфиксных операций</a><ul>
<li><a href="#приоритет-функции-композиции">Приоритет функции композиции</a></li>
<li><a href="#приоритет-функции-применения">Приоритет функции применения</a></li>
</ul></li>
<li><a href="#функциональный-калькулятор">Функциональный калькулятор</a></li>
<li><a href="#функции-возвращающие-несколько-значений">Функции, возвращающие несколько значений</a></li>
<li><a href="#комбинатор-неподвижной-точки">Комбинатор неподвижной точки</a></li>
<li><a href="#краткое-содержание">Краткое содержание</a><ul>
<li><a href="#основные-функции-высшего-порядка">Основные функции высшего порядка</a></li>
<li><a href="#приоритет-инфиксных-операций-1">Приоритет инфиксных операций</a></li>
</ul></li>
<li><a href="#упражнения">Упражнения</a></li>
</ul></li>
</ul>
</div>
<div id="header">  
<div id="nav">
<a id="prev" class="button" href="4.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="6.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>  
 </div> 

<h1 id="функции-высшего-порядка"><a href="#функции-высшего-порядка">Функции высшего порядка</a></h1>
<p> <em>Функцией высшего порядка</em> называют функцию, которая может принимать на вход функции или возвращать функции в качестве результата. За счёт частичного применения в Haskell все функции, которые принимают более одного аргумента, являются функциями высшего порядка.</p>
<p>В этой главе мы подробно обсудим способы составления функций, недаром Haskell – функциональный язык. В Haskell функции являются очень гибким объектом, они позволяют выделять сложные способы комбинирования значений. Часто за счёт развитых средств составления новых функций в Haskell пользователь определяет лишь базовые функции, получая остальные “на лету” применением двух-трёх операций, это выглядит примерно как <code><font color=Black>(</font><font color="#0000ee">2</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font><font color=Black>*</font><font color="#0000ee">5</font></code>, где вместо чисел стоят базовые функции, а операции <code><font color=Black>+</font></code> и <code><font color=Black>*</font></code> составляют новые функции из простейших.</p>
<h2 id="обобщённые-функции"><a href="#обобщённые-функции">Обобщённые функции</a></h2>
<p>В этом разделе мы познакомимся с несколькими функциями, которые принимают одни функции и составляют по ним другие. Эти функции используются в Haskell очень часто. Все они живут в модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font></code>. Модуль <code><font color=Green>Prelude</font></code> экспортирует их из этого модуля.</p>
<h3 id="функция-тождества"><a href="#функция-тождества">Функция тождества</a></h3>
<p>Начнём с самой простой функции. Это функция <code><font color=Black>id</font></code>. Она ничего не делает с аргументом, просто возвращает его:</p>
<pre><font color=Black>id</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a
<font color=Black>id</font> x <font color="#b2590f">=</font> x</pre>
<p>Зачем нам может понадобиться такая функция? Сама по себе она бесполезна. Она приобретает ценность при совместном использовании с другими функциями, поэтому пока мы не будем приводить примеров.</p>
<h3 id="константная-функция"><a href="#константная-функция">Константная функция</a></h3>
<p>Следующая функция <code><font color=Black>const</font></code> принимает значение и возвращает постоянную функцию. Эта функция будет возвращать константу для любого переданного в неё значения:</p>
<pre><font color=Black>const</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> a
<font color=Black>const</font> a <font color="#b2590f">_</font> <font color="#b2590f">=</font> a</pre>
<p>Функция <code><font color=Black>const</font></code> является конструктором постоянных функций, так например мы получаем пятёрки на любой аргумент:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> onlyFive <font color="#b2590f">=</font> const <font color="#0000ee">5</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>t onlyFive 
<font color=Black>onlyFive</font> <font color="#b2590f">::</font> b <font color="#b2590f">-&gt;</font> <font color=Green>Integer</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> onlyFive <font color=Black>"Hi"</font>
<font color="#0000ee">5</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> onlyFive <font color=Black>(</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>)</font>
<font color="#0000ee">5</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> map onlyFive <font color=Black>"abracadabra"</font>
<font color="#b2590f">[</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">5</font><font color="#b2590f">]</font></pre>
<p>С её помощью мы можем легко построить и постоянную функцию двух аргументов:</p>
<pre><font color=Black>const2</font> a <font color="#b2590f">=</font> const <font color=Black>(</font>const a<font color=Black>)</font></pre>
<p>Вспомним определение для <code><font color=Black>&amp;&amp;</font></code>:</p>
<pre><font color=Black>(</font><font color=Black>&amp;&amp;</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>(</font><font color=Black>&amp;&amp;</font><font color=Black>)</font> <font color=Green>True</font>   x  <font color="#b2590f">=</font> x
<font color=Black>(</font><font color=Black>&amp;&amp;</font><font color=Black>)</font> <font color=Green>False</font>  <font color="#b2590f">_</font>  <font color="#b2590f">=</font> <font color=Green>False</font>  </pre>
<p>С помощью функций <code><font color=Black>id</font></code> и <code><font color=Black>const</font></code> мы можем сократить число аргументов и уравнений:</p>
<pre><font color=Black>(</font><font color=Black>&amp;&amp;</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>(</font><font color=Black>&amp;&amp;</font><font color=Black>)</font> a <font color="#b2590f">=</font> <font color="#b2590f">if</font> a <font color="#b2590f">then</font> id <font color="#b2590f">else</font> <font color=Black>(</font>const <font color=Green>False</font><font color=Black>)</font></pre>
<p>Также мы можем определить и логическое “или”:</p>
<pre><font color=Black>(</font><font color=Black>||</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>(</font><font color=Black>||</font><font color=Black>)</font> a <font color="#b2590f">=</font> <font color="#b2590f">if</font> a <font color="#b2590f">then</font> <font color=Black>(</font>const <font color=Green>True</font><font color=Black>)</font> <font color="#b2590f">else</font> id</pre>
<h3 id="функция-композиции"><a href="#функция-композиции">Функция композиции</a></h3>
<p>Функция композиции принимает две функции и составляет из них последовательное применение функций:</p>
<pre><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> c
<font color=Black>(</font><font color=Black>.</font><font color=Black>)</font> f g <font color="#b2590f">=</font> <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> f <font color=Black>(</font>g x<font color=Black>)</font></pre>
<p>Это очень полезная функция. Она позволяет нанизывать функции друг на друга. Мы перехватываем выход второй функции, сразу подставляем его в первую и возвращаем её выход в качестве результата. Например перевернём список символов и затем сделаем все буквы заглавными:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>m <font color=Black>+</font><font color=Green>Data</font><font color=Black>.</font><font color=Green>Char</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Char</font><font color=Black>&gt;</font> <font color=Black>(</font>map toUpper <font color=Black>.</font> reverse<font color=Black>)</font> <font color=Black>"abracadabra"</font>
<font color=Black>"ARBADACARBA"</font></pre>
<p>Приведём пример посложнее:</p>
<pre><font color=Black>add</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font>
<font color=Black>add</font>  a  <font color=Green>Zero</font>     <font color="#b2590f">=</font> a
<font color=Black>add</font>  a  <font color=Black>(</font><font color=Green>Succ</font> b<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font>add a b<font color=Black>)</font></pre>
<p>Если мы определим функцию свёртки для <code><font color=Green>Nat</font></code>, которая будет заменять в значении типа <code><font color=Green>Nat</font></code> конструкторы на соответствующие по типу функции:</p>
<pre><font color=Black>foldNat</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>foldNat</font> zero succ <font color=Green>Zero</font>     <font color="#b2590f">=</font> zero
<font color=Black>foldNat</font> zero succ <font color=Black>(</font><font color=Green>Succ</font> b<font color=Black>)</font> <font color="#b2590f">=</font> succ <font color=Black>(</font>foldNat zero succ b<font color=Black>)</font></pre>
<p>То мы можем переписать с помощью функции композиции эту функцию так:</p>
<pre><font color=Black>add</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font>
<font color=Black>add</font> <font color="#b2590f">=</font> foldNat  id  <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font></pre>
<p>Куда делись аргументы? Они выражаются через функции <code><font color=Black>id</font></code> и <code><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font></code>. Поведение этой функции лучше проиллюстрировать на примере. Пусть у нас есть два числа типа <code><font color=Green>Nat</font></code>:</p>
<pre><font color=Black>two</font>     <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font>
<font color=Black>three</font>   <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Вычислим</p>
<pre><font color=Black>add</font> two three</pre>
<p>Вспомним о частичном применении:</p>
<pre>    add two three 
<font color="#b2590f">=&gt;</font>  <font color=Black>(</font>add two<font color=Black>)</font> three
<font color="#b2590f">=&gt;</font>  <font color=Black>(</font>foldNat id <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font> three</pre>
<p>Теперь функция свёртки заменит все конструкторы <code><font color=Green>Succ</font></code> на <code><font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font></code>, а конструкторы <code><font color=Green>Zero</font></code> на <code><font color=Black>id</font></code>:</p>
<pre><font color="#b2590f">=&gt;</font>  <font color=Black>(</font><font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font> <font color=Black>(</font><font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font> id<font color=Black>)</font><font color=Black>)</font> three</pre>
<p>Что это за монстр?</p>
<pre><font color=Black>(</font><font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font> <font color=Black>(</font><font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font> id<font color=Black>)</font><font color=Black>)</font></pre>
<p>Функция <code><font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font></code> это левое сечение операции <code><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font></code>. Эта функция, которая принимает функции и возвращает функции. Она принимает функцию и навешивает на её выход конструктор <code><font color=Green>Succ</font></code>. Давайте упростим это большое выражение с помощью определений функций <code><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font></code> и <code><font color=Black>id</font></code>:</p>
<pre>    <font color=Black>(</font><font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font> <font color=Black>(</font><font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font> id<font color=Black>)</font><font color=Black>)</font>
<font color="#b2590f">=&gt;</font>   <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font> <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> <font color=Green>Succ</font> <font color=Black>(</font>id x<font color=Black>)</font><font color=Black>)</font>
<font color="#b2590f">=&gt;</font>   <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>.</font> <font color=Black>)</font> <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> <font color=Green>Succ</font> x<font color=Black>)</font>
<font color="#b2590f">=&gt;</font>   <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> x<font color=Black>)</font></pre>
<p>Теперь нам осталось применить к этой функции наше второе значение:</p>
<pre>    <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> x<font color=Black>)</font><font color=Black>)</font> three
<font color="#b2590f">=&gt;</font>  <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> three<font color=Black>)</font>
<font color="#b2590f">=&gt;</font>  <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> x<font color=Black>)</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Так мы получили, что и ожидалось от сложения. За каждый конструктор <code><font color=Green>Succ</font></code> в первом аргументе мы добавляем применение <code><font color=Green>Succ</font></code> к результату, а вместо <code><font color=Green>Zero</font></code> протаскиваем через <code><font color=Black>id</font></code> второй аргумент.</p>
<h3 id="аналогия-с-числами"><a href="#аналогия-с-числами">Аналогия с числами</a></h3>
<p>С помощью функции композиции мы можем нанизывать друг на друга списки функций. Попробуем в интерпретаторе:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> f <font color="#b2590f">=</font> foldr <font color=Black>(</font><font color=Black>.</font><font color=Black>)</font> id <font color="#b2590f">[</font>sin<font color=Black>,</font> cos<font color=Black>,</font> sin<font color=Black>,</font> cos<font color=Black>,</font> exp<font color=Black>,</font> <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font><font color=Black>,</font> tan<font color="#b2590f">]</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> f <font color="#0000ee">2</font>
<font color="#0000ee">0.6330525927559899</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> f <font color="#0000ee">15</font>
<font color="#0000ee">0.7978497904127007</font></pre>
<p>Функция <code><font color=Black>foldr</font></code> заменит в списке каждый конструктор <code><font color=Black>(</font><font color="#b2590f">:</font><font color=Black>)</font></code> на функцию композиции, а пустой список на функцию <code><font color=Black>id</font></code>. В результате получается композиция из всех функций в списке.</p>
<p>Это очень похоже на сложение или умножение чисел в списке. При этом в качестве нуля (для сложения) или единицы (для умножения) мы используем функцию <code><font color=Black>id</font></code>. Мы пользуемся тем, что по определению для любой функции <code><font color=Black>f</font></code> выполнены тождества:</p>
<pre><font color=Black>f</font>  <font color=Black>.</font> id  <font color=Black>==</font>  f
<font color=Black>id</font> <font color=Black>.</font> f   <font color=Black>==</font>  f</pre>
<p>Поэтому мы можем использовать <code><font color=Black>id</font></code> в качестве накопителя результата композиции, как в случае:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> foldr <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> <font color="#0000ee">1</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>
<font color="#0000ee">24</font></pre>
<p>Если сравнить <code><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font></code> с умножением, то <code><font color=Black>id</font></code> похоже на единицу, а <code><font color=Black>(</font>const a<font color=Black>)</font></code> на ноль. В самом деле для любой функции <code><font color=Black>f</font></code> и любого значения <code><font color=Black>a</font></code> выполнено тождество:</p>
<pre><font color=Black>const</font> a  <font color=Black>.</font>  f  <font color=Black>==</font> const a</pre>
<p>Мы словно умножаем функцию на ноль, делая её вычисление бессмысленным.</p>
<h3 id="функция-перестановки"><a href="#функция-перестановки">Функция перестановки</a></h3>
<p>Функция перестановки <code><font color=Black>flip</font></code> принимает функцию двух аргументов и меняет аргументы местами:</p>
<pre><font color=Black>flip</font>  <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> c
<font color=Black>flip</font> f x y <font color="#b2590f">=</font> f y x</pre>
<p>К примеру:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> foldr <font color=Black>(</font><font color="#2149c1">-</font><font color=Black>)</font> <font color="#0000ee">0</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>
<font color="#2149c1">-</font><font color="#0000ee">2</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> foldr <font color=Black>(</font>flip <font color=Black>(</font><font color="#2149c1">-</font><font color=Black>)</font><font color=Black>)</font> <font color="#0000ee">0</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>
<font color="#2149c1">-</font><font color="#0000ee">10</font></pre>
<p>Иногда это бывает полезно.</p>
<h3 id="функция-on"><a href="#функция-on">Функция on</a></h3>
<p>Функция <code><font color=Black>on</font></code> (от англ. на) перед применением бинарной функции пропускает аргументы через унарную функцию:</p>
<pre><font color=Black>on</font> <font color="#b2590f">::</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> c
<font color=Black>(</font><font color=Black>.*.</font><font color=Black>)</font> <font color=Black>`on`</font> f <font color="#b2590f">=</font> <font color="#b2590f">\</font>x y <font color="#b2590f">-&gt;</font> f x <font color=Black>.*.</font> f y</pre>
<p>Она часто используется в сочетании с функцией <code><font color=Black>sortBy</font></code> из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font></code>. Эта функция имеет тип:</p>
<pre><font color=Black>sortBy</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ordering</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font></pre>
<p>Она сортирует элементы списка согласно некоторой функции упорядочивания <code><font color=Black>f</font> <font color="#b2590f">::</font>  <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ordering</font><font color=Black>)</font></code>. С помощью функции <code><font color=Black>on</font></code> мы можем легко составить такую функцию на лету:</p>
<pre><font color="#b2590f">let</font> xs <font color="#b2590f">=</font> <font color="#b2590f">[</font><font color=Black>(</font><font color="#0000ee">3</font><font color=Black>,</font> <font color=Black>"John"</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color="#0000ee">2</font><font color=Black>,</font> <font color=Black>"Jack"</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color="#0000ee">34</font><font color=Black>,</font> <font color=Black>"Jim"</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color="#0000ee">100</font><font color=Black>,</font> <font color=Black>"Jenny"</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color="#2149c1">-</font><font color="#0000ee">3</font><font color=Black>,</font> <font color=Black>"Josh"</font><font color=Black>)</font><font color="#b2590f">]</font>  
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>m <font color=Black>+</font><font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font><font color=Black>&gt;</font> 
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font><font color=Black>&gt;</font> sortBy <font color=Black>(</font>compare <font color=Black>`on`</font> fst<font color=Black>)</font> xs
<font color="#b2590f">[</font><font color=Black>(</font><font color="#2149c1">-</font><font color="#0000ee">3</font><font color=Black>,</font><font color=Black>"Josh"</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color="#0000ee">2</font><font color=Black>,</font><font color=Black>"Jack"</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color="#0000ee">3</font><font color=Black>,</font><font color=Black>"John"</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color="#0000ee">34</font><font color=Black>,</font><font color=Black>"Jim"</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color="#0000ee">100</font><font color=Black>,</font><font color=Black>"Jenny"</font><font color=Black>)</font><font color="#b2590f">]</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font><font color=Black>&gt;</font> map fst <font color=Black>(</font>sortBy <font color=Black>(</font>compare <font color=Black>`on`</font> fst<font color=Black>)</font> xs<font color=Black>)</font>
<font color="#b2590f">[</font><font color="#2149c1">-</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">34</font><font color=Black>,</font><font color="#0000ee">100</font><font color="#b2590f">]</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font><font color=Black>&gt;</font> map snd <font color=Black>(</font>sortBy <font color=Black>(</font>compare <font color=Black>`on`</font> fst<font color=Black>)</font> xs<font color=Black>)</font>
<font color="#b2590f">[</font><font color=Black>"Josh"</font><font color=Black>,</font><font color=Black>"Jack"</font><font color=Black>,</font><font color=Black>"John"</font><font color=Black>,</font><font color=Black>"Jim"</font><font color=Black>,</font><font color=Black>"Jenny"</font><font color="#b2590f">]</font></pre>
<p>Мы импортировали в интерпретатор модуль <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font></code> для функции <code><font color=Black>sortBy</font></code> а также модуль <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font></code> для функции <code><font color=Black>on</font></code>. Они не импортируются модулем <code><font color=Green>Prelude</font></code>.</p>
<p>Выражением <code><font color=Black>(</font>compare <font color=Black>`on`</font> fst<font color=Black>)</font></code> мы составили функцию</p>
<pre><font color="#b2590f">\</font>a b <font color="#b2590f">-&gt;</font> compare <font color=Black>(</font>fst a<font color=Black>)</font> <font color=Black>(</font>fst b<font color=Black>)</font>

<font color=Black>fst</font> <font color="#b2590f">=</font> <font color="#b2590f">\</font><font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a</pre>
<p>Тем самым ввели функцию упорядочивания на парах, которая будет сравнивать пары по первому элементу. Отметим, что аналогичного эффекта можно добиться с помощью функции <code><font color=Black>comparing</font></code> из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Ord</font></code>.</p>
<h3 id="функция-применения"><a href="#функция-применения">Функция применения</a></h3>
<p>Ещё одной очень полезной функцией является функция применения <code><font color=Black>(</font><font color=Black>$</font><font color=Black>)</font></code>. Посмотрим на её определение:</p>
<pre><font color=Black>(</font><font color=Black>$</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> b
<font color=Black>f</font> <font color=Black>$</font> x  <font color="#b2590f">=</font>  f x</pre>
<p>На первый взгляд её определение может показаться бессмысленным. Зачем нам специальный знак для применения, если у нас уже есть пробел? Для ответа на этот вопрос нам придётся познакомиться с приоритетом инфиксных операций.</p>
<h2 id="приоритет-инфиксных-операций"><a href="#приоритет-инфиксных-операций">Приоритет инфиксных операций</a></h2>
<p>В Haskell очень часто используются бинарные операции для составления функций “на лету”. В этом помогает и частичное применение, мы можем в одном выражении применить к функции часть аргументов, построить из неё новую функцию с помощью какой-нибудь такой бинарной операции и всё это передать в другую функцию!</p>
<p>Для сокращения числа скобок нам понадобится разобраться в понятии приоритета операции. Так например в выражении</p>
<pre><font color=Black>&gt;</font> <font color="#0000ee">2</font> <font color=Black>+</font> <font color="#0000ee">3</font> <font color=Black>*</font> <font color="#0000ee">10</font>
<font color="#0000ee">32</font></pre>
<p>Мы полагаем, что умножение имеет больший приоритет чем сложение и со скобками это выражение будет выглядеть так:</p>
<pre><font color=Black>&gt;</font> <font color="#0000ee">2</font> <font color=Black>+</font> <font color=Black>(</font><font color="#0000ee">3</font> <font color=Black>*</font> <font color="#0000ee">10</font><font color=Black>)</font>
<font color="#0000ee">32</font></pre>
<p>Фраза “больший приоритет” означает: сначала умножение потом сложение. Мы всегда можем изменить поведение по умолчанию с помощью скобок:</p>
<pre><font color=Black>&gt;</font> <font color=Black>(</font><font color="#0000ee">2</font> <font color=Black>+</font> <font color="#0000ee">3</font><font color=Black>)</font> <font color=Black>*</font> <font color="#0000ee">10</font>
<font color="#0000ee">50</font></pre>
<p>В Haskell приоритет функций складывается из двух понятий: старшинство и ассоциативность. Старшинство определяется числами, они могут быть от 0 до 9. Чем больше это число, тем выше приоритет функций.</p>
<p>Старшинство используется вычислителем для группировки разных операций, например <code><font color=Black>(</font><font color=Black>+</font><font color=Black>)</font></code> имеет старшинство 6, а <code><font color=Black>(</font><font color=Black>*</font><font color=Black>)</font></code> имеет старшинство 7. Поэтому интерпретатор сначала ставит скобки вокруг выражения с <code><font color=Black>(</font><font color=Black>*</font><font color=Black>)</font></code>, а затем вокруг <code><font color=Black>(</font><font color=Black>+</font><font color=Black>)</font></code>. Считается, что обычное префиксное применение имеет высший приоритет 10. Нельзя задать приоритет выше применения, это значит, что операция “пробел” будет всегда выполняться первой.</p>
<p>Ассоциативность используется для группировки одинаковых операций, например мы видим:</p>
<pre><font color="#0000ee">1</font><font color=Black>+</font><font color="#0000ee">2</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>+</font><font color="#0000ee">4</font></pre>
<p>Как нам быть? Мы можем группировать скобки слева направо:</p>
<pre><font color=Black>(</font><font color=Black>(</font><font color="#0000ee">1</font><font color=Black>+</font><font color="#0000ee">2</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">4</font></pre>
<p>Или справа налево:</p>
<pre><font color="#0000ee">1</font><font color=Black>+</font><font color=Black>(</font><font color="#0000ee">2</font><font color=Black>+</font><font color=Black>(</font><font color="#0000ee">3</font><font color=Black>+</font><font color="#0000ee">4</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Ответ на этот вопрос даёт ассоциативность, она бывает левая и правая. Например операции <code><font color=Black>(</font><font color=Black>+</font><font color=Black>)</font></code> <code><font color=Black>(</font><font color="#2149c1">-</font><font color=Black>)</font></code> и (*) являются лево-ассоциативными, а операция возведения в степень <code><font color=Black>(</font><font color=Black>^</font><font color=Black>)</font></code> является право-ассоциативной.</p>
<pre><font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font> <font color=Black>+</font> <font color="#0000ee">3</font> <font color=Black>==</font> <font color=Black>(</font><font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color=Black>+</font> <font color="#0000ee">3</font>
<font color="#0000ee">1</font> <font color=Black>^</font> <font color="#0000ee">2</font> <font color=Black>^</font> <font color="#0000ee">3</font> <font color=Black>==</font>  <font color="#0000ee">1</font> <font color=Black>^</font> <font color=Black>(</font><font color="#0000ee">2</font> <font color=Black>^</font> <font color="#0000ee">3</font><font color=Black>)</font></pre>
<p>Приоритет функции можно узнать в интерпретаторе с помощью команды <code><font color="#b2590f">:</font>i</code>:</p>
<pre><font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>m <font color=Green>Prelude</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font>
<font color="#b2590f">class</font> <font color=Black>(</font><font color=Green>Eq</font> a<font color=Black>,</font> <font color=Green>Show</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Num</font> a <font color="#b2590f">where</font>
  <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
  <font color=Black>...</font>
  	<font color="#2149c1">-- Defined in GHC.Num</font>
<font color="#b2590f">infixl</font> <font color="#0000ee">6</font> <font color=Black>+</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font>
<font color="#b2590f">class</font> <font color=Black>(</font><font color=Green>Eq</font> a<font color=Black>,</font> <font color=Green>Show</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Num</font> a <font color="#b2590f">where</font>
  <font color=Black>...</font>
  <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
  <font color=Black>...</font>
  	<font color="#2149c1">-- Defined in GHC.Num</font>
<font color="#b2590f">infixl</font> <font color="#0000ee">7</font> <font color=Black>*</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i <font color=Black>(</font><font color=Black>^</font><font color=Black>)</font>
<font color=Black>(</font><font color=Black>^</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Num</font> a<font color=Black>,</font> <font color=Green>Integral</font> b<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> a 	<font color="#2149c1">-- Defined in GHC.Real</font>
<font color="#b2590f">infixr</font> <font color="#0000ee">8</font> <font color=Black>^</font></pre>
<p>Приоритет указывается в строчках <code><font color="#b2590f">infixl</font> <font color="#0000ee">6</font> <font color=Black>+</font></code> и <code><font color="#b2590f">infixl</font> <font color="#0000ee">7</font> <font color=Black>*</font></code>. Цифра указывает на старшинство операции, а суффикс <code><font color=Black>l</font></code> (от англ. left – левая) или <code><font color=Black>r</font></code> (от англ. right – правая) на ассоциативность.</p>
<p>Если мы создали свою функцию, мы можем определить для неё ассоциативность. Для этого мы пишем в коде:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Fixity</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>Prelude</font><font color=Black>(</font><font color=Green>Num</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>)</font>

<font color="#b2590f">infixl</font> <font color="#0000ee">4</font> <font color=Black>***</font> 
<font color="#b2590f">infixl</font> <font color="#0000ee">5</font> <font color=Black>+++</font>
<font color="#b2590f">infixr</font> <font color="#0000ee">5</font> <font color=Black>`neg`</font>

<font color=Black>(</font><font color=Black>***</font><font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font>
<font color=Black>(</font><font color=Black>+++</font><font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font>
<font color=Black>neg</font>   <font color="#b2590f">=</font> <font color=Black>(</font><font color="#2149c1">-</font><font color=Black>)</font></pre>
<p>Мы ввели новые операции и поменяли старшинство операций сложения и умножения местами и изменили ассоциативность у вычитания. Проверим в интерпретаторе:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Fixity</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Fixity</font>           <font color=Black>(</font> <font color=Green>Fixity</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Fixity</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Fixity</font><font color=Black>&gt;</font> <font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font> <font color=Black>*</font> <font color="#0000ee">3</font>
<font color="#0000ee">7</font>
<font color=Black>*</font><font color=Green>Fixity</font><font color=Black>&gt;</font> <font color="#0000ee">1</font> <font color=Black>+++</font> <font color="#0000ee">2</font> <font color=Black>***</font> <font color="#0000ee">3</font>
<font color="#0000ee">9</font>
<font color=Black>*</font><font color=Green>Fixity</font><font color=Black>&gt;</font> <font color="#0000ee">1</font> <font color="#2149c1">-</font> <font color="#0000ee">2</font> <font color="#2149c1">-</font> <font color="#0000ee">3</font>
<font color="#2149c1">-</font><font color="#0000ee">4</font>
<font color=Black>*</font><font color=Green>Fixity</font><font color=Black>&gt;</font> <font color="#0000ee">1</font> <font color=Black>`neg`</font> <font color="#0000ee">2</font> <font color=Black>`neg`</font> <font color="#0000ee">3</font>
<font color="#0000ee">2</font></pre>
<p>Посмотрим как это вычислялось:</p>
<pre><font color="#0000ee">1</font>   <font color=Black>+</font>   <font color="#0000ee">2</font>   <font color=Black>*</font>  <font color="#0000ee">3</font>  <font color=Black>==</font>   <font color="#0000ee">1</font>   <font color=Black>+</font>   <font color=Black>(</font><font color="#0000ee">2</font>    <font color=Black>*</font>   <font color="#0000ee">3</font><font color=Black>)</font>
<font color="#0000ee">1</font>  <font color=Black>+++</font>  <font color="#0000ee">2</font>  <font color=Black>***</font> <font color="#0000ee">3</font>  <font color=Black>==</font>  <font color=Black>(</font><font color="#0000ee">1</font>  <font color=Black>+++</font>   <font color="#0000ee">2</font><font color=Black>)</font>  <font color=Black>***</font>  <font color="#0000ee">3</font>

<font color="#0000ee">1</font>   <font color="#2149c1">-</font>   <font color="#0000ee">2</font>   <font color="#2149c1">-</font>  <font color="#0000ee">3</font>  <font color=Black>==</font>  <font color=Black>(</font><font color="#0000ee">1</font>   <font color="#2149c1">-</font>    <font color="#0000ee">2</font><font color=Black>)</font>   <font color="#2149c1">-</font>   <font color="#0000ee">3</font>
<font color="#0000ee">1</font> <font color=Black>`neg`</font> <font color="#0000ee">2</font> <font color=Black>`</font>neg <font color="#0000ee">3</font><font color=Black>`</font> <font color=Black>==</font>   <font color="#0000ee">1</font> <font color=Black>`neg`</font> <font color=Black>(</font><font color="#0000ee">2</font>  <font color=Black>`neg`</font> <font color="#0000ee">3</font><font color=Black>)</font></pre>
<p>Также в Haskell есть директива <code><font color="#b2590f">infix</font></code> это тоже самое, что и <code><font color="#b2590f">infixl</font></code>.</p>
<h3 id="приоритет-функции-композиции"><a href="#приоритет-функции-композиции">Приоритет функции композиции</a></h3>
<p>Посмотрим на приоритет функции композиции:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i <font color=Black>(</font><font color=Black>.</font><font color=Black>)</font>
<font color=Black>(</font><font color=Black>.</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> c 	<font color="#2149c1">-- Defined in GHC.Base</font>
<font color="#b2590f">infixr</font> <font color="#0000ee">9</font> <font color=Black>.</font></pre>
<p>Она имеет высший приоритет. Она очень часто используется при определении функции в бесточечном стиле. Такая функция похожа на конвейер функций:</p>
<pre><font color=Black>fun</font> a <font color="#b2590f">=</font> fun1 a <font color=Black>.</font> fun2 <font color=Black>(</font>x1 <font color=Black>+</font> x2<font color=Black>)</font> <font color=Black>.</font> fun3 <font color=Black>.</font> <font color=Black>(</font><font color=Black>+</font>x1<font color=Black>)</font> </pre>
<h3 id="приоритет-функции-применения"><a href="#приоритет-функции-применения">Приоритет функции применения</a></h3>
<p>Теперь посмотрим на полное определение функции применения:</p>
<pre><font color="#b2590f">infixr</font> <font color="#0000ee">0</font> <font color=Black>$</font>

<font color=Black>(</font><font color=Black>$</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> b
<font color=Black>f</font> <font color=Black>$</font> x  <font color="#b2590f">=</font>  f x</pre>
<p>Ответ на вопрос о полезности этой функции кроется в её приоритете. Ей назначен самый низкий приоритет. Она будет исполняться в последнюю очередь. Очень часто возникают ситуации вроде:</p>
<pre><font color=Black>foldNat</font> zero succ <font color=Black>(</font><font color=Green>Succ</font> b<font color=Black>)</font> <font color="#b2590f">=</font> succ <font color=Black>(</font>foldNat zero succ b<font color=Black>)</font></pre>
<p>С помощью функции применения мы можем переписать это определение так:</p>
<pre><font color=Black>foldNat</font> zero succ <font color=Black>(</font><font color=Green>Succ</font> b<font color=Black>)</font> <font color="#b2590f">=</font> succ <font color=Black>$</font> foldNat zero succ b</pre>
<p>Если бы мы написали без скобок:</p>
<pre><font color=Black>...</font> <font color="#b2590f">=</font> succ foldNat zero succ b</pre>
<p>То выражение было бы сгруппировано так:</p>
<pre><font color=Black>...</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>(</font><font color=Black>(</font>succ foldNat<font color=Black>)</font> zero<font color=Black>)</font> succ<font color=Black>)</font> b</pre>
<p>Но поскольку мы поставили барьер в виде операции <code><font color=Black>(</font><font color=Black>$</font><font color=Black>)</font></code> с низким приоритетом, группировка скобок произойдёт так:</p>
<pre><font color=Black>...</font> <font color="#b2590f">=</font> <font color=Black>(</font>succ <font color=Black>$</font> <font color=Black>(</font><font color=Black>(</font>foldNat zero<font color=Black>)</font> succ<font color=Black>)</font> b<font color=Black>)</font></pre>
<p>Это как раз то, что нам нужно. Преимущество этого подхода проявляется особенно ярко если у нас несколько вложенных функций на конце выражения:</p>
<pre><font color=Black>xs</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font>
<font color=Black>xs</font> <font color="#b2590f">=</font> reverse <font color=Black>$</font> map <font color=Black>(</font><font color=Black>(</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>.</font> <font color=Black>(</font><font color=Black>*</font><font color="#0000ee">10</font><font color=Black>)</font><font color=Black>)</font> <font color=Black>$</font> filter even <font color=Black>$</font> ns <font color="#0000ee">40</font>

<font color=Black>ns</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font>
<font color=Black>ns</font> <font color="#0000ee">0</font>  <font color="#b2590f">=</font> <font color=Green>[]</font>
<font color=Black>ns</font> n  <font color="#b2590f">=</font> n <font color="#b2590f">:</font> ns <font color=Black>(</font>n <font color="#2149c1">-</font> <font color="#0000ee">1</font><font color=Black>)</font></pre>
<p>В списке <code><font color=Black>xs</font></code> мы сначала создаём в функции <code><font color=Black>ns</font></code> убывающий список чисел, затем оставляем лишь чётные, потом применяем два арифметических действия ко всем элементам списка, затем переворачиваем список.</p>
<p>Проверим работает ли это в интерпретаторе, заодно поупражняемся в композиционном стиле:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> ns n <font color="#b2590f">=</font> <font color="#b2590f">if</font> <font color=Black>(</font>n <font color=Black>==</font> <font color="#0000ee">0</font><font color=Black>)</font> <font color="#b2590f">then</font> <font color=Green>[]</font> <font color="#b2590f">else</font> n <font color="#b2590f">:</font> ns <font color=Black>(</font>n <font color="#2149c1">-</font> <font color="#0000ee">1</font><font color=Black>)</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> even x <font color="#b2590f">=</font> <font color="#0000ee">0</font> <font color=Black>==</font> mod x <font color="#0000ee">2</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> xs <font color="#b2590f">=</font> reverse <font color=Black>$</font> map <font color=Black>(</font><font color=Black>(</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>.</font> <font color=Black>(</font><font color=Black>*</font><font color="#0000ee">10</font><font color=Black>)</font><font color=Black>)</font> <font color=Black>$</font> filter even <font color=Black>$</font> ns <font color="#0000ee">20</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> xs 
<font color="#b2590f">[</font><font color="#0000ee">21</font><font color=Black>,</font><font color="#0000ee">41</font><font color=Black>,</font><font color="#0000ee">61</font><font color=Black>,</font><font color="#0000ee">81</font><font color=Black>,</font><font color="#0000ee">101</font><font color=Black>,</font><font color="#0000ee">121</font><font color=Black>,</font><font color="#0000ee">141</font><font color=Black>,</font><font color="#0000ee">161</font><font color=Black>,</font><font color="#0000ee">181</font><font color=Black>,</font><font color="#0000ee">201</font><font color="#b2590f">]</font></pre>
<p>Если бы не функция применения нам пришлось бы написать это выражение так:</p>
<pre><font color=Black>xs</font> <font color="#b2590f">=</font> reverse <font color=Black>(</font>map <font color=Black>(</font><font color=Black>(</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>.</font> <font color=Black>(</font><font color=Black>*</font><font color="#0000ee">10</font><font color=Black>)</font><font color=Black>)</font> <font color=Black>(</font>filter even <font color=Black>(</font>ns <font color="#0000ee">40</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font></pre>
<h2 id="функциональный-калькулятор"><a href="#функциональный-калькулятор">Функциональный калькулятор</a></h2>
<p>Мне бы хотелось сделать акцент на одном из вступительных предложений этой главы:</p>
<blockquote>
<p>За счёт развитых средств составления новых функций в Haskell пользователь определяет лишь базовые функции, получая остальные “на лету” применением двух-трёх операций, это выглядит примерно как <code><font color=Black>(</font><font color="#0000ee">2</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font><font color=Black>*</font><font color="#0000ee">5</font></code>, где вместо чисел стоят базовые функции, а операции <code><font color=Black>+</font></code> и <code><font color=Black>*</font></code> составляют новые функции из простейших.</p>
</blockquote>
<p>Такие обобщённые функции как <code><font color=Black>id</font></code>, <code><font color=Black>const</font></code>, <code><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font></code>, <code><font color=Black>map</font></code> <code><font color=Black>filter</font></code> позволяют очень легко комбинировать различные функции. Бесточечный стиль записи функций превращает функции в простые значения или значения-константы, которые можно подставлять в другие функции. В этом разделе мы немного потренируемся в перегрузке численных значений и превратим числа в функции, функции и в самом деле станут константами. Мы определим экземпляр <code><font color=Green>Num</font></code> для функций, которые возвращают числа. Смысл этих операций заключается в том, что теперь мы применяем обычные операции сложения умножения к функциям, аргумент которых совпадает по типу. Например для того чтобы умножить функции <code><font color="#b2590f">\</font>t <font color="#b2590f">-&gt;</font> t<font color=Black>+</font><font color="#0000ee">2</font></code> и <code><font color="#b2590f">\</font>t <font color="#b2590f">-&gt;</font> t<font color=Black>+</font><font color="#0000ee">3</font></code> мы составляем новую функцию <code><font color="#b2590f">\</font>t <font color="#b2590f">-&gt;</font> <font color=Black>(</font>t<font color=Black>+</font><font color="#0000ee">2</font><font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>t<font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font></code>, которая получает на вход значение <code><font color=Black>t</font></code> применяет его к каждой из функций и затем умножает результаты:</p>
<pre><font color="#b2590f">module</font> <font color=Green>FunNat</font> <font color="#b2590f">where</font>

<font color="#b2590f">instance</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Num</font> <font color=Black>(</font>t <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color="#b2590f">=</font> fun2 <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font>
    <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> <font color="#b2590f">=</font> fun2 <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font>
    <font color=Black>(</font><font color="#2149c1">-</font><font color=Black>)</font> <font color="#b2590f">=</font> fun2 <font color=Black>(</font><font color="#2149c1">-</font><font color=Black>)</font>

    abs      <font color="#b2590f">=</font> fun1 abs
    signum   <font color="#b2590f">=</font> fun1 signum

    fromInteger <font color="#b2590f">=</font> const <font color=Black>.</font> fromInteger

<font color=Black>fun1</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Black>(</font>t <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>t <font color="#b2590f">-&gt;</font> b<font color=Black>)</font><font color=Black>)</font>
<font color=Black>fun1</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>.</font><font color=Black>)</font>

<font color=Black>fun2</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Black>(</font>t <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>t <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>t <font color="#b2590f">-&gt;</font> c<font color=Black>)</font><font color=Black>)</font>
<font color=Black>fun2</font> op a b <font color="#b2590f">=</font> <font color="#b2590f">\</font>t <font color="#b2590f">-&gt;</font> a t <font color=Black>`op`</font> b t</pre>
<p>Функции <code><font color=Black>fun1</font></code> и <code><font color=Black>fun2</font></code> превращают функции, которые принимают значения, в функции, которые принимают другие функции. Загрузим модуль <code><font color=Green>FunNat</font></code> в интерпретатор и посмотрим что же у нас получилось:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>FunNat</font><font color=Black>.</font>hs
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>FunNat</font>           <font color=Black>(</font> <font color=Green>FunNat</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>FunNat</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> <font color="#0000ee">2</font> <font color="#0000ee">2</font>
<font color="#0000ee">2</font>
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> <font color="#0000ee">2</font> <font color="#0000ee">5</font>
<font color="#0000ee">2</font>
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> <font color=Black>(</font><font color="#0000ee">2</font> <font color=Black>+</font> <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font><font color=Black>)</font> <font color="#0000ee">0</font> 
<font color="#0000ee">3</font>
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> <font color=Black>(</font><font color=Black>(</font><font color=Black>+</font><font color="#0000ee">2</font><font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font><font color=Black>)</font> <font color="#0000ee">1</font>
<font color="#0000ee">12</font></pre>
<p>На первый взгляд кажется что выражение <code><font color="#0000ee">2</font> <font color="#0000ee">2</font></code> не должно пройти проверку типов, ведь мы применяем значение к константе. Но на самом деле <code><font color="#0000ee">2</font></code> это не константа, а значение <code><font color="#0000ee">2</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> a</code> и подспудно к двойке применяется функция <code><font color=Black>fromInteger</font></code>. Поскольку в нашем модуле мы определили экземпляр <code><font color=Green>Num</font></code> для функций, второе число <code><font color="#0000ee">2</font></code> было конкретизировано по умолчанию до <code><font color=Green>Integer</font></code>, а первое число <code><font color="#0000ee">2</font></code> было конкретизировано до <code><font color=Green>Integer</font> <font color="#b2590f">-&gt;</font> <font color=Green>Integer</font></code>. Компилятор вывел из контекста, что под <code><font color="#0000ee">2</font></code> мы понимаем функцию. Функция была создана с помощью метода <code><font color=Black>fromInteger</font></code>. Эта функция принимает любое значение и возвращает двойку.</p>
<p>Далее мы складываем и перемножаем функции словно это обычные значения. Что интересно мы можем составлять и такие выражения:</p>
<pre><font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> f <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color="#2149c1">-</font> <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> f <font color="#0000ee">1</font> <font color="#0000ee">2</font>
<font color="#0000ee">1</font></pre>
<p>Как была вычислена эта функция? Мы определили экземпляр функций для значений типа <code><font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> t <font color="#b2590f">-&gt;</font> a</code>. Если мы вспомним, что функция двух аргументов на самом деле является функцией одного аргумента: <code><font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> t1 <font color="#b2590f">-&gt;</font> <font color=Black>(</font>t2 <font color="#b2590f">-&gt;</font> a<font color=Black>)</font></code>, мы заметим, что тип <code><font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Black>(</font>t2 <font color="#b2590f">-&gt;</font> a<font color=Black>)</font></code> принадлежит <code><font color=Green>Num</font></code>, теперь если мы обозначим его за <code><font color=Black>a'</font></code>, то мы получим тип <code><font color=Green>Num</font> a' <font color="#b2590f">=&gt;</font> t1 <font color="#b2590f">-&gt;</font> a'</code>, это совпадает с нашим исходным экземпляром.</p>
<p>Получается, что за счёт механизма частичного применения мы одним махом определили экземпляры <code><font color=Green>Num</font></code> для функций <em>любого</em> числа аргументов, которые возвращают значение типа <code><font color=Green>Num</font></code>.</p>
<p>Итак функция <code><font color=Black>f</font></code> имеет вид:</p>
<pre><font color="#b2590f">\</font>t1 t2 <font color="#b2590f">-&gt;</font> <font color=Black>(</font>t1 <font color=Black>+</font> t2<font color=Black>)</font> <font color="#2149c1">-</font> <font color=Black>(</font>t1 <font color=Black>*</font> t2<font color=Black>)</font></pre>
<p>Теперь давайте составим несколько выражений с обобщёнными функциями. Составим функцию, которая принимает один аргумент, умножает его на два, вычитает 10 и берёт модуль числа.</p>
<pre><font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> f <font color="#b2590f">=</font> abs <font color=Black>$</font> id <font color=Black>*</font> <font color="#0000ee">2</font> <font color="#2149c1">-</font> <font color="#0000ee">10</font> 
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> f <font color="#0000ee">2</font>
<font color="#0000ee">6</font>
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> f <font color="#0000ee">10</font>
<font color="#0000ee">10</font></pre>
<p>Давайте посмотрим как была составлена эта функция:</p>
<pre>    abs <font color=Black>$</font> id <font color=Black>*</font> <font color="#0000ee">2</font> <font color="#2149c1">-</font> <font color="#0000ee">10</font>                   

<font color="#b2590f">=&gt;</font>  abs <font color=Black>$</font> <font color=Black>(</font>id <font color=Black>*</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color="#2149c1">-</font> <font color="#0000ee">10</font>                 <font color="#2149c1">-- приоритет умножения</font>
<font color="#b2590f">=&gt;</font>  abs <font color=Black>$</font> <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> x <font color=Black>*</font> <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color="#2149c1">-</font> <font color="#0000ee">10</font>      <font color="#2149c1">-- развернём id и 2</font>
<font color="#b2590f">=&gt;</font>  abs <font color=Black>$</font> <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> x <font color=Black>*</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color="#2149c1">-</font> <font color="#0000ee">10</font>            <font color="#2149c1">-- по определению (*) для функций</font>
<font color="#b2590f">=&gt;</font>  abs <font color=Black>$</font> <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> x <font color=Black>*</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color="#2149c1">-</font> <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> <font color="#0000ee">10</font>      <font color="#2149c1">-- развернём 10</font>
<font color="#b2590f">=&gt;</font>  abs <font color=Black>$</font> <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> <font color=Black>(</font>x <font color=Black>*</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color="#2149c1">-</font> <font color="#0000ee">10</font>            <font color="#2149c1">-- по определению (-) для функций</font>
<font color="#b2590f">=&gt;</font>  <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> abs x <font color=Black>.</font> <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> <font color=Black>(</font>x <font color=Black>*</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color="#2149c1">-</font> <font color="#0000ee">10</font>    <font color="#2149c1">-- по определению abs для функций</font>
<font color="#b2590f">=&gt;</font>  <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> abs <font color=Black>(</font><font color=Black>(</font>x <font color=Black>*</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color="#2149c1">-</font> <font color="#0000ee">10</font><font color=Black>)</font>            <font color="#2149c1">-- по определению (.)</font>

<font color="#b2590f">=&gt;</font>  <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> abs <font color=Black>(</font><font color=Black>(</font>x <font color=Black>*</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color="#2149c1">-</font> <font color="#0000ee">10</font><font color=Black>)</font></pre>
<p>Функция возведения в квадрат:</p>
<pre><font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> f <font color="#b2590f">=</font> id <font color=Black>*</font> id
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> map f <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">5</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">9</font><font color=Black>,</font><font color="#0000ee">16</font><font color=Black>,</font><font color="#0000ee">25</font><font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> map <font color=Black>(</font>id <font color=Black>*</font> id <font color="#2149c1">-</font> <font color="#0000ee">1</font><font color=Black>)</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">5</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">0</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">15</font><font color=Black>,</font><font color="#0000ee">24</font><font color="#b2590f">]</font></pre>
<p>Обратите внимание на краткость записи. В этом выражении <code><font color=Black>(</font>id <font color=Black>*</font> id <font color="#2149c1">-</font> <font color="#0000ee">1</font><font color=Black>)</font></code> проявляется основное преимущество бесточечного стиля, избавившись от аргументов, мы можем пользоваться функциями так, словно это простые значения. Этот приём используется в Haskell очень активно. Пока нам встретились лишь две инфиксных операции для функций (это композиция и применение с низким приоритетом), но в будущем вы столкнётесь с целым морем подобных операций. Все они служат одной цели, они прячут аргументы функции, позволяя быстро составлять функции на лету из примитивов.</p>
<p>Возведём в четвёртую степень:</p>
<pre><font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> map <font color=Black>(</font>f <font color=Black>.</font> f<font color=Black>)</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">5</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">16</font><font color=Black>,</font><font color="#0000ee">81</font><font color=Black>,</font><font color="#0000ee">256</font><font color=Black>,</font><font color="#0000ee">625</font><font color="#b2590f">]</font></pre>
<p>Составим функцию двух аргументов, которая будет вычислять сумму квадратов двух аргументов:</p>
<pre><font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> x <font color="#b2590f">=</font> const
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> y <font color="#b2590f">=</font> flip const
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> d <font color="#b2590f">=</font> x <font color=Black>*</font> x <font color=Black>+</font> y <font color=Black>*</font> y
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> d <font color="#0000ee">1</font> <font color="#0000ee">2</font>
<font color="#0000ee">5</font>
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> d <font color="#0000ee">3</font> <font color="#0000ee">2</font>
<font color="#0000ee">13</font></pre>
<p>Так мы составили функцию, ни прибегая к помощи аргументов. Эти выражения могут стать частью других выражений:</p>
<pre><font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> filter  <font color=Black>(</font><font color=Black>(</font><font color=Black>&lt;</font><font color="#0000ee">10</font><font color=Black>)</font> <font color=Black>.</font> d <font color="#0000ee">1</font><font color=Black>)</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">5</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> zipWith d <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color="#b2590f">]</font> <font color="#b2590f">[</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">1</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">10</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">10</font><font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>FunNat</font><font color=Black>&gt;</font> foldr <font color=Black>(</font>x<font color=Black>*</font>x <font color="#2149c1">-</font> y<font color=Black>*</font>y<font color=Black>)</font> <font color="#0000ee">0</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>
<font color="#0000ee">-3721610024</font></pre>
<h2 id="функции-возвращающие-несколько-значений"><a href="#функции-возвращающие-несколько-значений">Функции, возвращающие несколько значений</a></h2>
<p> Как было сказано ранее функции, которые возвращают несколько значений, реализованы в Haskell с помощью кортежей. Например функция, которая расщепляет поток на голову и хвост выглядит так:</p>
<pre><font color=Black>decons</font> <font color="#b2590f">::</font> <font color=Green>Stream</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> <font color=Green>Stream</font> a<font color=Black>)</font>
<font color=Black>decons</font> <font color=Black>(</font>a <font color="#b2590f">:&amp;</font> <font color="#b2590f">as</font><font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>a<font color=Black>,</font> <font color="#b2590f">as</font><font color=Black>)</font></pre>
<p>Здесь функция возвращает сразу два значения. Но всегда ли уместно пользоваться кортежами? Для композиции функций, которые возвращают несколько значений нам придётся разбирать возвращаемые значения с помощью сопоставления с образцом и затем использовать эти значения в других функциях. Посудите сами если у нас есть функции:</p>
<pre><font color=Black>f</font> <font color="#b2590f">::</font> a  <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b1<font color=Black>,</font> b2<font color=Black>)</font>
<font color=Black>g</font> <font color="#b2590f">::</font> b1 <font color="#b2590f">-&gt;</font> <font color=Black>(</font>c1<font color=Black>,</font> c2<font color=Black>)</font>
<font color=Black>h</font> <font color="#b2590f">::</font> b2 <font color="#b2590f">-&gt;</font> <font color=Black>(</font>c3<font color=Black>,</font> c4<font color=Black>)</font></pre>
<p>Мы уже не сможем комбинировать их так просто как если бы это были обычные функции без кортежей.</p>
<pre><font color=Black>q</font> x <font color="#b2590f">=</font> <font color=Black>(</font><font color="#b2590f">\</font><font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>g a<font color=Black>,</font> h b<font color=Black>)</font><font color=Black>)</font> <font color=Black>(</font>f x<font color=Black>)</font></pre>
<p>В случае пар нам могут прийти на помощь функции <code><font color=Black>first</font></code> и <code><font color=Black>second</font></code>:</p>
<pre><font color=Black>q</font> <font color="#b2590f">=</font> first g <font color=Black>.</font> second h <font color=Black>.</font> f</pre>
<p>Если мы захотим составить какую-нибудь другую функцию из <code><font color=Black>q</font></code>, то ситуация заметно усложнится. Функции, возвращающие кортежи, сложнее комбинировать в бесточечном стиле. Здесь стоит вспомнить правило Unix.</p>
<blockquote>
<p>Пишите функции, которые делают одну вещь, но делают её хорошо.</p>
</blockquote>
<p>Функция, которая возвращает кортеж пытается сделать сразу несколько дел. И теряет в гибкости, ей трудно взаимодействовать с другими функциями. Старайтесь чтобы таких функций было как можно меньше.</p>
<p>Если функция возвращает несколько значений, попытайтесь разбить её на несколько, которые возвращают лишь одно значение. Часто бывает так, что эти значения тесно связаны между собой и такую функцию не удаётся разбить на несколько составляющих. Если у вас появляется много таких функций, то это повод задуматься о создании нового типа данных.</p>
<p>Например в качестве точки на плоскости можно использовать пару <code><font color=Black>(</font><font color=Green>Float</font><font color=Black>,</font> <font color=Green>Float</font><font color=Black>)</font></code>. В этом случае, если вы начнёте писать модуль на геометрическую тему у вас появится много функций, которые принимают и возвращают точки:</p>
<pre><font color=Black>rotate</font>      <font color="#b2590f">::</font> <font color=Green>Float</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Float</font><font color=Black>,</font> <font color=Green>Float</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Float</font><font color=Black>,</font> <font color=Green>Float</font><font color=Black>)</font>
<font color=Black>norm</font>        <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Float</font><font color=Black>,</font> <font color=Green>Float</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Float</font><font color=Black>,</font> <font color=Green>Float</font><font color=Black>)</font>
<font color=Black>translate</font>   <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Float</font><font color=Black>,</font> <font color=Green>Float</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Float</font><font color=Black>,</font> <font color=Green>Float</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Float</font><font color=Black>,</font> <font color=Green>Float</font><font color=Black>)</font>
<font color=Black>...</font>    </pre>
<p>Все они стараются делать несколько дел одновременно, возвращая кортежи. Но мы можем изменить ситуацию определением новых типов:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Point</font>  <font color="#b2590f">=</font> <font color=Green>Point</font>  <font color=Green>Float</font> <font color=Green>Float</font>
<font color="#b2590f">data</font> <font color=Green>Vector</font> <font color="#b2590f">=</font> <font color=Green>Vector</font> <font color=Green>Float</font> <font color=Green>Float</font>
<font color="#b2590f">data</font> <font color=Green>Angle</font>  <font color="#b2590f">=</font> <font color=Green>Angle</font>  <font color=Green>Float</font></pre>
<p>Объявления функций станут более краткими и наглядными.</p>
<pre><font color=Black>rotate</font>      <font color="#b2590f">::</font> <font color=Green>Angle</font>  <font color="#b2590f">-&gt;</font> <font color=Green>Point</font> <font color="#b2590f">-&gt;</font> <font color=Green>Point</font>
<font color=Black>norm</font>        <font color="#b2590f">::</font> <font color=Green>Point</font>  <font color="#b2590f">-&gt;</font> <font color=Green>Point</font>
<font color=Black>translate</font>   <font color="#b2590f">::</font> <font color=Green>Vector</font> <font color="#b2590f">-&gt;</font> <font color=Green>Point</font> <font color="#b2590f">-&gt;</font> <font color=Green>Point</font>
<font color=Black>...</font>    </pre>
<h2 id="комбинатор-неподвижной-точки"><a href="#комбинатор-неподвижной-точки">Комбинатор неподвижной точки</a></h2>
<p>Познакомимся с функцией <code><font color=Black>fix</font></code> или комбинатором неподвижной точки. По хорошему об этой функции следовало бы рассказать в разделе обобщённые функции. Но я пропустил её нарочно, для простоты изложения. В этом разделе градус сложности резко подскакивает, если вы ранее не встречались с этой функцией она может показаться вам очень необычной. Для начала посмотрим на её тип:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>m <font color=Black>+</font><font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>t fix
<font color=Black>fix</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a</pre>
<p>Странно, <code><font color=Black>fix</font></code> принимает функцию и возвращает значение, обычно всё происходит наоборот. Теперь посмотрим на определение:</p>
<pre><font color=Black>fix</font> f <font color="#b2590f">=</font> <font color="#b2590f">let</font> x <font color="#b2590f">=</font> f x
        <font color="#b2590f">in</font>  x</pre>
<p>Если вы запутались, то по смыслу это определение равносильно такому:</p>
<pre><font color=Black>fix</font> f <font color="#b2590f">=</font> f <font color=Black>(</font>fix f<font color=Black>)</font></pre>
<p>Функция <code><font color=Black>fix</font></code> берёт функцию и начинает бесконечно нанизывать её саму на себя. Так мы получаем, что-то вроде:</p>
<pre><font color=Black>f</font> <font color=Black>(</font>f <font color=Black>(</font>f <font color=Black>(</font>f <font color=Black>(</font><font color=Black>...</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Зачем нам такая функция? Помните в самом конце четвёртой главы в упражнениях мы составляли бесконечные потоки. Мы делали это так:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Stream</font> a <font color="#b2590f">=</font> a <font color="#b2590f">:&amp;</font> <font color=Green>Stream</font> a

<font color=Black>constStream</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> a
<font color=Black>constStream</font> a <font color="#b2590f">=</font> a <font color="#b2590f">:&amp;</font> constStream a</pre>
<p>Если смотреть на функцию <code><font color=Black>constStream</font></code> очень долго, то рано или поздно в ней проглянет функция <code><font color=Black>fix</font></code>. Я нарочно не буду выписывать, а вы мысленно обозначьте <code><font color=Black>(</font>a <font color="#b2590f">:&amp;</font><font color=Black>)</font></code> за <code><font color=Black>f</font></code> и <code><font color=Black>constStream</font> a</code> за <code><font color=Black>fix</font> f</code>. Получилось?</p>
<p>Через <code><font color=Black>fix</font></code> можно очень просто определить бесконечность для <code><font color=Green>Nat</font></code>, бесконечность это цепочка <code><font color=Green>Succ</font></code>, которая никогда не заканчивается <code><font color=Green>Zero</font></code>. Оказывается, что в Haskell мы можем составлять выражения с такими значениями (как вычислителю удаётся справиться с бесконечными выражениями мы обсудим попозже):</p>
<pre><font color=Black>ghci</font> <font color=Green>Nat</font>
<font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font>m <font color=Black>+</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font>
<font color=Black>*</font><font color=Green>Nat</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> infinity <font color="#b2590f">=</font> fix <font color=Green>Succ</font>
<font color=Black>*</font><font color=Green>Nat</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font><font color=Black>&gt;</font> infinity <font color=Black>&lt;</font> <font color=Green>Succ</font> <font color=Green>Zero</font>
<font color=Green>False</font></pre>
<p>С помощью функции <code><font color=Black>fix</font></code> можно выразить любую рекурсивную функцию. Посмотрим на примере функции <code><font color=Black>foldNat</font></code>, у нас есть рекурсивное определение:</p>
<pre><font color=Black>foldNat</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>foldNat</font> z  s  <font color=Green>Zero</font>      <font color="#b2590f">=</font> z
<font color=Black>foldNat</font> z  s  <font color=Black>(</font><font color=Green>Succ</font> n<font color=Black>)</font>  <font color="#b2590f">=</font> s <font color=Black>(</font>foldNat z s n<font color=Black>)</font></pre>
<p>Необходимо привести его к виду:</p>
<pre><font color=Black>x</font> <font color="#b2590f">=</font> f x</pre>
<p>Слева и справа мы видим повторяются выражения <code><font color=Black>foldNat</font> z s</code>, обозначим их за <code><font color=Black>x</font></code>:</p>
<pre><font color=Black>x</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>x</font> <font color=Green>Zero</font>      <font color="#b2590f">=</font> z
<font color=Black>x</font> <font color=Black>(</font><font color=Green>Succ</font> n<font color=Black>)</font>  <font color="#b2590f">=</font> s <font color=Black>(</font>x n<font color=Black>)</font></pre>
<p>Теперь перенесём первый аргумент в правую часть, сопоставление с образцом превратится в <code><font color="#b2590f">case</font></code>-выражение:</p>
<pre><font color=Black>x</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>x</font> <font color="#b2590f">=</font> <font color="#b2590f">\</font>nat <font color="#b2590f">-&gt;</font> <font color="#b2590f">case</font> nat <font color="#b2590f">of</font>
                <font color=Green>Zero</font>    <font color="#b2590f">-&gt;</font> z
                <font color=Green>Succ</font> n  <font color="#b2590f">-&gt;</font> s <font color=Black>(</font>x n<font color=Black>)</font></pre>
<p>В правой части вынесем <code><font color=Black>x</font></code> из выражения с помощью лямбда функции:</p>
<pre><font color=Black>x</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>x</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color="#b2590f">\</font>t <font color="#b2590f">-&gt;</font> <font color="#b2590f">\</font>nat <font color="#b2590f">-&gt;</font> <font color="#b2590f">case</font> nat <font color="#b2590f">of</font>
                        <font color=Green>Zero</font>    <font color="#b2590f">-&gt;</font> z
                        <font color=Green>Succ</font> n  <font color="#b2590f">-&gt;</font> s <font color=Black>(</font>t n<font color=Black>)</font><font color=Black>)</font> x </pre>
<p>Смотрите, для этого мы обозначили вхождение <code><font color=Black>x</font></code> в выражении справа за <code><font color=Black>t</font></code> и создали лямбда-функцию с таким аргументом.</p>
<p>Получилось! Мы пришли к виду комбинатора неподвижной точки:</p>
<pre><font color=Black>x</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>x</font> <font color="#b2590f">=</font> f x
    <font color="#b2590f">where</font> f <font color="#b2590f">=</font> <font color="#b2590f">\</font>t <font color="#b2590f">-&gt;</font> <font color="#b2590f">\</font>nat <font color="#b2590f">-&gt;</font> <font color="#b2590f">case</font> nat <font color="#b2590f">of</font>
                        <font color=Green>Zero</font>    <font color="#b2590f">-&gt;</font> z
                        <font color=Green>Succ</font> n  <font color="#b2590f">-&gt;</font> s <font color=Black>(</font>t n<font color=Black>)</font></pre>
<p>Приведём в более человеческий вид:</p>
<pre><font color=Black>foldNat</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> a<font color=Black>)</font>
<font color=Black>foldNat</font> z s <font color="#b2590f">=</font> fix f
    <font color="#b2590f">where</font> f t <font color="#b2590f">=</font> <font color="#b2590f">\</font>nat <font color="#b2590f">-&gt;</font> <font color="#b2590f">case</font> nat <font color="#b2590f">of</font>
                            <font color=Green>Zero</font>    <font color="#b2590f">-&gt;</font> z
                            <font color=Green>Succ</font> n  <font color="#b2590f">-&gt;</font> s <font color=Black>(</font>t n<font color=Black>)</font></pre>
<h2 id="краткое-содержание"><a href="#краткое-содержание">Краткое содержание</a></h2>
<h3 id="основные-функции-высшего-порядка"><a href="#основные-функции-высшего-порядка">Основные функции высшего порядка</a></h3>
<p>Мы познакомились с функциями из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font></code>. Их можно разбить на несколько типов:</p>
<ul>
<li>Примитивные функции (генераторы функций).</li>
</ul>
<pre><font color=Black>id</font>      <font color="#b2590f">=</font> <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> x
<font color=Black>const</font> a <font color="#b2590f">=</font> <font color="#b2590f">\</font><font color="#b2590f">_</font> <font color="#b2590f">-&gt;</font> a</pre>
<ul>
<li>Функции, которые комбинируют функции или функции и значения:</li>
</ul>
<pre><font color=Black>f</font> <font color=Black>.</font> g  <font color="#b2590f">=</font> <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> f <font color=Black>(</font>g x<font color=Black>)</font>
<font color=Black>f</font> <font color=Black>$</font> x  <font color="#b2590f">=</font> f x

<font color=Black>(</font><font color=Black>.*.</font><font color=Black>)</font> <font color=Black>`on`</font> f <font color="#b2590f">=</font> <font color="#b2590f">\</font>x y <font color="#b2590f">-&gt;</font> f x <font color=Black>.*.</font> f y</pre>
<ul>
<li>Преобразователи функций, принимают функцию и возвращают функцию:</li>
</ul>
<pre><font color=Black>flip</font> f <font color="#b2590f">=</font> <font color="#b2590f">\</font>x y <font color="#b2590f">-&gt;</font> f y x</pre>
<ul>
<li>Комбинатор неподвижной точки:</li>
</ul>
<pre><font color=Black>fix</font> f <font color="#b2590f">=</font> <font color="#b2590f">let</font> x <font color="#b2590f">=</font> f x
        <font color="#b2590f">in</font>  x</pre>
<h3 id="приоритет-инфиксных-операций-1"><a href="#приоритет-инфиксных-операций-1">Приоритет инфиксных операций</a></h3>
<p>Мы узнали о специальном синтаксисе для задания приоритета применения функций в инфиксной форме:</p>
<pre><font color="#b2590f">infixl</font> <font color="#0000ee">3</font> <font color=Black><em>#</em></font>
<font color="#b2590f">infixr</font> <font color="#0000ee">6</font> <font color=Black>`op`</font></pre>
<p>Приоритет складывается из двух частей: старшинства (от 1 до 9) и ассоциативности (бывает левая и правая). Старшинство определяет распределение скобок между разными функциями:</p>
<pre><font color="#b2590f">infixl</font> <font color="#0000ee">6</font> <font color=Black>+</font>
<font color="#b2590f">infixl</font> <font color="#0000ee">7</font> <font color=Black>*</font>

<font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font> <font color=Black>*</font> <font color="#0000ee">3</font> <font color=Black>==</font> <font color="#0000ee">1</font> <font color=Black>+</font> <font color=Black>(</font><font color="#0000ee">2</font> <font color=Black>*</font> <font color="#0000ee">3</font><font color=Black>)</font></pre>
<p>А ассоциативность – между одинаковыми:</p>
<pre><font color="#b2590f">infixl</font> <font color="#0000ee">6</font> <font color=Black>+</font>
<font color="#b2590f">infixr</font> <font color="#0000ee">8</font> <font color=Black>^</font>

<font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font> <font color=Black>+</font> <font color="#0000ee">3</font> <font color=Black>==</font> <font color=Black>(</font><font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color=Black>+</font> <font color="#0000ee">3</font>    
<font color="#0000ee">1</font> <font color=Black>^</font> <font color="#0000ee">2</font> <font color=Black>^</font> <font color="#0000ee">3</font> <font color=Black>==</font>  <font color="#0000ee">1</font> <font color=Black>^</font> <font color=Black>(</font><font color="#0000ee">2</font> <font color=Black>^</font> <font color="#0000ee">3</font><font color=Black>)</font>  </pre>
<p>Мы узнали, что функции <code><font color=Black>(</font><font color=Black>$</font><font color=Black>)</font></code> и <code><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font></code> стоят на разных концах шкалы приоритетов функций и как этим пользоваться.</p>
<h2 id="упражнения"><a href="#упражнения">Упражнения</a></h2>
<ul>
<li><p>Просмотрите написанные вами функции, или функции из примеров. Можно ли их переписать с помощью основных функций высшего порядка? Если да, то перепишите. Попробуйте определить их в бесточечном стиле.</p></li>
<li><p>В прошлой главе у нас было упражнение о потоках. Сделайте поток экземпляром класса <code><font color=Green>Num</font></code>. Для этого поток должен содержать значения из класса <code><font color=Green>Num</font></code>. Методы из класса <code><font color=Green>Num</font></code> применяются поэлементно. Так сложение двух потоков будет выглядеть так:</p>
<pre><font color=Black>(</font>a1 <font color="#b2590f">:&amp;</font> a2 <font color="#b2590f">:&amp;</font> a3 <font color="#b2590f">:&amp;</font> <font color=Black>...</font><font color=Black>)</font> <font color=Black>+</font> <font color=Black>(</font>b1 <font color="#b2590f">:&amp;</font> b2 <font color="#b2590f">:&amp;</font> b3<font color=Black>)</font> <font color=Black>==</font>
<font color=Black>==</font>  <font color=Black>(</font>a1 <font color=Black>+</font> b1 <font color="#b2590f">:&amp;</font> a2 <font color=Black>+</font> b2 <font color="#b2590f">:&amp;</font> a3 <font color=Black>+</font> b3 <font color="#b2590f">:&amp;</font> <font color=Black>...</font><font color=Black>)</font></pre></li>
<li><p>Определите приоритет инфиксной операции <code><font color=Black>(</font><font color="#b2590f">:&amp;</font><font color=Black>)</font></code><br /> так чтобы вам было удобно использовать её в сочетании с арифметическими операциями.</p></li>
<li><p>Рассмотрим такой тип:</p>
<pre><font color="#b2590f">data</font> <font color=Green>St</font> a b <font color="#b2590f">=</font> <font color=Green>St</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b<font color=Black>,</font> <font color=Green>St</font> a b<font color=Black>)</font><font color=Black>)</font></pre>
<p>Этот тип хранит функцию, которая позволяет преобразовывать потоки значений. Определите функцию применения:</p>
<pre><font color=Black>ap</font> <font color="#b2590f">::</font> <font color=Green>St</font> a b <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font></pre>
<p>Она принимает ленту входящих значений и возвращает ленту выходов. Определите для этого типа несколько основных функций высшего порядка. Чтобы не возникало конфликта имён с модулем <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font></code> мы не будем его импортировать. Вместо него мы импортируем модуль <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Category</font></code>. Он содержит класс:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Category</font> cat <font color="#b2590f">where</font>
        id  <font color="#b2590f">::</font> cat a a
        <font color=Black>(</font><font color=Black>.</font><font color=Black>)</font> <font color="#b2590f">::</font> cat b c <font color="#b2590f">-&gt;</font> cat a b <font color="#b2590f">-&gt;</font> cat a c</pre>
<p>Если присмотреться к типам функций, можно понять, что тип-экземпляр <code><font color=Black>cat</font></code> принимает два параметра. Совсем как тип функции <code><font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font></code>. Формально его можно записать в префиксной форме так <code><font color=Black>(</font><font color="#b2590f">-&gt;</font><font color=Black>)</font> a b</code>. Получается, что тип <code><font color=Black>cat</font></code> это что-то вроде функции. Это некоторые сущности, у которых есть понятия тождества и композиции.</p>
<p>Для обычных функций экземпляр класса <code><font color=Green>Category</font></code> уже определён. Но в этом модуле у нас есть ещё и необычные функции, функции которые преобразуют ленты значений. Функции <code><font color=Black>id</font></code> и <code><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font></code> мы определим, сделав наш тип <code><font color=Green>St</font></code> экземпляром класса <code><font color=Green>Category</font></code>. Также определите постоянный преобразователь. Он на любой вход возвращает одно и то же число, и преобразователь, который будет накапливать сумму поступающих на вход значений, по-другому такой преобразователь называют интегратором:</p>
<pre><font color=Black>const</font>    <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Green>St</font> b a
<font color=Black>integral</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>St</font> a a</pre></li>
<li><p>Перепишите с помощью <code><font color=Black>fix</font></code> несколько стандартных функций для списков. Например <code><font color=Black>map</font></code>, <code><font color=Black>foldr</font></code>, <code><font color=Black>foldl</font></code>, <code><font color=Black>zip</font></code>, <code><font color=Black>repeat</font></code>, <code><font color=Black>cycle</font></code>, <code><font color=Black>iterate</font></code>.</p>
<p>Старайтесь найти наиболее краткое выражение, пользуйтесь функциями высшего порядка и частичным применением. Например рассмотрим функцию <code><font color=Black>repeat</font></code>:</p>
<pre><font color=Black>repeat</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>repeat</font> a <font color="#b2590f">=</font> a <font color="#b2590f">:</font> repeat a</pre>
<p>Запишем с <code><font color=Black>fix</font></code>:</p>
<pre><font color=Black>repeat</font> a <font color="#b2590f">=</font> fix <font color=Black>$</font> <font color="#b2590f">\</font>xs <font color="#b2590f">-&gt;</font> a <font color="#b2590f">:</font> xs</pre>
<p>Заметим, что мы можем избавиться от аргумента <code><font color=Black>xs</font></code> с помощью сечения:</p>
<pre><font color=Black>repeat</font> a <font color="#b2590f">=</font> fix <font color=Black>(</font>a<font color="#b2590f">:</font><font color=Black>)</font></pre>
<p>Но мы можем пойти ещё дальше, если вспомним, что функция двух аргументов <code><font color=Black>(</font><font color="#b2590f">:</font><font color=Black>)</font></code> является функцией от одного аргумента <code><font color=Black>(</font><font color="#b2590f">:</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color=Black>)</font></code>, которая возвращает функцию одного аргумента:</p>
<pre><font color=Black>repeat</font> <font color="#b2590f">=</font> fix <font color=Black>.</font> <font color=Black>(</font><font color="#b2590f">:</font><font color=Black>)</font></pre>
<p>Смотрите в этом выражении мы составили композицию двух функций. Функция <code><font color=Black>(</font><font color="#b2590f">:</font><font color=Black>)</font></code> примет первый аргумент и вернёт функцию, как раз то, что и нужно для <code><font color=Black>fix</font></code>.</p></li>
</ul>
<div id="footer">  
<div id="nav">
<a id="prev" class="button" href="4.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="6.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>
<div id="nav"> <div id="prev-name">
<ol start="4" style="list-style-type: decimal">
<li>Декларативный и композиционный стиль
</div> <div id="wrap-next-name"><div id="next-name">
<ol start="6" style="list-style-type: decimal">
<li>Функторы и монады: теория
</div></div></div>  
 </div> 
</li>
</ol></li>
</ol>
<div id="license">
Зарегистрировано под лицензией <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative commons Attribution-NonCommercial-NoDerivs</a> 3.0 Generic (CC BY-NC-ND 3.0)
</div>
</body>
</html>
